# Quantum Echo
Projekt gry w pygame na przedmiot symulacje i gry decyzyjne

## Kluczowe Cechy

*   **Innowacyjna rozgrywka** oparta na mechanice Echa Czasowego i Kwantowej Zamiany.
*   **Poziomy zaprojektowane** jako zÅ‚oÅ¼one zagadki logiczno-zrÄ™cznoÅ›ciowe.
*   **Platformy czasowe**, ktÃ³re cyklicznie zmieniajÄ… swÃ³j stan, wymuszajÄ…c idealne zgranie w czasie.
*   **System power-upÃ³w**: podwÃ³jny skok i tarcza nietykalnoÅ›ci, ktÃ³re moÅ¼na wykorzystaÄ‡ strategicznie.
*   **Klucze i zamkniÄ™te wyjÅ›cia** dodajÄ…ce warstwÄ™ eksploracji i planowania.
*   **Estetyka Pixel Art** z dynamicznie generowanym, unikalnym tÅ‚em dla kaÅ¼dego poziomu.
*   **Efekty czÄ…steczkowe** i wizualne, ktÃ³re wzbogacajÄ… rozgrywkÄ™.
*   **System rankingu** do Å›ledzenia najlepszych wynikÃ³w.
*   **Tryb treningowy** pozwalajÄ…cy na swobodne Ä‡wiczenie na dowolnym poziomie.
*   **PeÅ‚ne wsparcie dla dÅºwiÄ™ku**: klimatyczna muzyka w menu i efekty dÅºwiÄ™kowe dla kluczowych akcji.

## GÅ‚Ä™bsze Spojrzenie na Mechaniki

`Quantum Echo` to wiÄ™cej niÅ¼ platformÃ³wka; to symulator podejmowania decyzji, w ktÃ³rym czas jest Twoim narzÄ™dziem, a przeszÅ‚oÅ›Ä‡ Twoim najwiÄ™kszym zasobem. KaÅ¼dy element gry zostaÅ‚ zaprojektowany, aby zmusiÄ‡ gracza do myÅ›lenia w czterech wymiarach.

### ğŸ§  MyÅ›lenie Przyczynowo-Skutkowe: Echo jako NarzÄ™dzie

Twoje **Echo** nie jest pasywnym cieniem. To zapis Twoich dziaÅ‚aÅ„ sprzed 10 sekund, ktÃ³ry posiada fizycznÄ… obecnoÅ›Ä‡ w Å›wiecie gry. MoÅ¼e ono wchodziÄ‡ w kolizje z platformami, zbieraÄ‡ przedmioty czy aktywowaÄ‡ mechanizmy. KaÅ¼dy TwÃ³j ruch, skok czy postÃ³j to inwestycja w przyszÅ‚oÅ›Ä‡. Musisz nieustannie zadawaÄ‡ sobie pytania:
*   "Gdzie moje Echo bÄ™dzie za 10 sekund, jeÅ›li teraz skoczÄ™ w to miejsce?"
*   "Czy mogÄ™ zostawiÄ‡ Echo na tej platformie czasowej, aby mÃ³c siÄ™ z nim zamieniÄ‡, gdy platforma zniknie pode mnÄ…?"
*   "Jak ustawiÄ‡ siÄ™ teraz, aby za 10 sekund Echo mogÅ‚o zebraÄ‡ klucz, podczas gdy ja bÄ™dÄ™ po drugiej stronie mapy?"

### âš›ï¸ Kwantowa Zamiana: Sedno Strategii

**Kwantowa Zamiana** to mechanika, ktÃ³ra zamienia grÄ™ zrÄ™cznoÅ›ciowÄ… w grÄ™ logicznÄ…. Jedno naciÅ›niÄ™cie klawisza `Q` pozwala na natychmiastowÄ… zamianÄ™ miejscami z Echem, co otwiera nieskoÅ„czone moÅ¼liwoÅ›ci taktyczne:
*   **Pokonywanie Pionowych PrzeszkÃ³d:** Skocz najwyÅ¼ej jak potrafisz, a nastÄ™pnie poczekaj. Gdy Twoje Echo powtÃ³rzy ten skok, zamieÅ„ siÄ™ z nim w najwyÅ¼szym punkcie, aby wylÄ…dowaÄ‡ na niedostÄ™pnej wczeÅ›niej pÃ³Å‚ce.
*   **Ucieczka z PuÅ‚apek:** WpadÅ‚eÅ› w miejsce bez wyjÅ›cia? JeÅ›li 10 sekund temu byÅ‚eÅ› w bezpiecznej pozycji, jeden przycisk moÅ¼e CiÄ™ tam przenieÅ›Ä‡, zostawiajÄ…c Echo w puÅ‚apce.
*   **Manipulacja Obiektami:** Ustaw siÄ™ na przycisku otwierajÄ…cym drzwi. OdejdÅº, a gdy Echo zajmie Twoje miejsce na przycisku, zamieÅ„ siÄ™ z nim, aby znaleÅºÄ‡ siÄ™ za otwartymi juÅ¼ drzwiami.

### â³ Drugie Å»ycie: PrzeszÅ‚oÅ›Ä‡ Ratuje PrzyszÅ‚oÅ›Ä‡

ÅšmierÄ‡ w `Quantum Echo` nie jest koÅ„cem, a lekcjÄ…. Po pierwszej poraÅ¼ce na poziomie przejmujesz kontrolÄ™ nad swoim Echem. Oznacza to, Å¼e dosÅ‚ownie cofasz siÄ™ w czasie o 10 sekund, aby przeÅ¼yÄ‡ na nowo swoje ostatnie chwile, ale tym razem z peÅ‚nÄ… Å›wiadomoÅ›ciÄ… nadchodzÄ…cego zagroÅ¼enia. Daje Ci to unikalnÄ… szansÄ™ na naprawienie bÅ‚Ä™du i zmianÄ™ swojego przeznaczenia.

### ğŸ§© Åšwiat PeÅ‚en WyzwaÅ„ Czasoprzestrzennych

Poziomy sÄ… zaprojektowane tak, aby w peÅ‚ni wykorzystaÄ‡ te mechaniki:
*   **Platformy Czasowe:** ZnikajÄ… i pojawiajÄ… siÄ™ w regularnych cyklach, zmuszajÄ…c do synchronizacji dziaÅ‚aÅ„ nie tylko z platformÄ…, ale rÃ³wnieÅ¼ z opÃ³Åºnionym ruchem Echa.
*   **Klucze i ZamkniÄ™te WyjÅ›cia:** CzÄ™sto klucz do wyjÅ›cia znajduje siÄ™ w miejscu, ktÃ³re staje siÄ™ niedostÄ™pne po jego zebraniu. Gracz musi zaplanowaÄ‡ sekwencjÄ™ ruchÃ³w i zamian, aby zarÃ³wno zdobyÄ‡ klucz, jak i zapewniÄ‡ sobie drogÄ™ ucieczki.
*   **Power-upy:** Przedmioty takie jak podwÃ³jny skok czy tarcza nietykalnoÅ›ci dodajÄ… kolejnÄ… warstwÄ™ do podejmowania decyzji. Czy uÅ¼yÄ‡ ich od razu, czy moÅ¼e zostawiÄ‡ je dla Echa, aby mogÅ‚o pokonaÄ‡ przeszkodÄ™ w przyszÅ‚oÅ›ci?

## Sterowanie

| Klawisz             | Akcja                  |
| ------------------- | ---------------------- |
| `A` / `D` / `â†` / `â†’` | Ruch w lewo / w prawo  |
| `Spacja`            | Skok / PodwÃ³jny skok   |
| `Q`                 | Kwantowa Zamiana z Echem |
| `M`                 | Wycisz / WÅ‚Ä…cz dÅºwiÄ™k  |
| `ESC`               | Pauza / PowrÃ³t do menu |---

## Architektura Kodu (`quantumecho.py`)

GÅ‚Ã³wny plik `quantumecho.py` stanowi serce caÅ‚ej aplikacji i zawiera kompletnÄ… logikÄ™ gry. Jego architektura opiera siÄ™ na kilku kluczowych koncepcjach:

### 1. Maszyna StanÃ³w Gry (`GameState`)
Gra jest zorganizowana jako maszyna stanÃ³w, co pozwala na czyste oddzielenie logiki rÃ³Å¼nych ekranÃ³w (menu, rozgrywka, pauza, ekran koÅ„ca poziomu itp.). Enum `GameState` definiuje wszystkie moÅ¼liwe stany, a gÅ‚Ã³wna pÄ™tla gry decyduje, ktÃ³rÄ… logikÄ™ aktualizowaÄ‡ i co rysowaÄ‡ na ekranie w zaleÅ¼noÅ›ci od aktywnego stanu.

### 2. GÅ‚Ã³wne Klasy
Projekt jest silnie zorientowany obiektowo, co uÅ‚atwia zarzÄ…dzanie poszczegÃ³lnymi elementami gry.

*   **Klasy Postaci:**
    *   `Player`: NajwaÅ¼niejsza klasa w grze. ZarzÄ…dza pozycjÄ…, fizykÄ… (grawitacja, kolizje), sterowaniem, power-upami oraz, co kluczowe, przechowuje historiÄ™ swoich ruchÃ³w w kolejce (`deque`). Na podstawie tej historii tworzone i aktualizowane jest **Echo**.

*   **Klasy ElementÃ³w Poziomu:**
    *   `Platform`: Podstawowy, statyczny lub poruszajÄ…cy siÄ™ blok.
    *   `TemporalPlatform`: Platforma czasowa, ktÃ³ra cyklicznie zmienia swÃ³j stan miÄ™dzy materialnym a niematerialnym, wprowadzajÄ…c element rytmu do rozgrywki.
    *   `Hazard`: Obiekty Å›miertelne dla gracza, np. kolce.
    *   `Collectible`: Przedmioty do zebrania (klejnoty, power-upy).
    *   `Key`: Klucz, ktÃ³ry gracz musi zebraÄ‡, aby odblokowaÄ‡ wyjÅ›cie.
    *   `ExitZone`: Cel poziomu, ktÃ³ry aktywuje siÄ™ po zebraniu wszystkich kluczy.

*   **Klasy ZarzÄ…dzajÄ…ce i Efektami:**
    *   `Level`: Odpowiada za wczytanie struktury poziomu z pliku `.json` i zainicjowanie wszystkich jego obiektÃ³w. DziaÅ‚a jako kontener na wszystkie elementy widoczne w grze.
    *   `LevelBackground`: Generuje unikalne, proceduralne tÅ‚o w stylu pixel art dla kaÅ¼dego poziomu, wÅ‚Ä…czajÄ…c w to chmury i gwiazdy z efektem paralaksy.
    *   `ParticleSystem`: ZarzÄ…dza efektami czÄ…steczkowymi, takimi jak eksplozje przy zamianie, Å›lady za postaciÄ… czy efekty przy zbieraniu przedmiotÃ³w, dodajÄ…c grze dynamiki.

### 3. Projekt Sterowany Danymi (Data-Driven Design)
Zamiast "hardkodowaÄ‡" poziomy w kodzie, gra wykorzystuje zewnÄ™trzne pliki `.json` do ich definiowania.
*   **Poziomy (`levels/*.json`)**: KaÅ¼dy plik JSON opisuje pozycje i wÅ‚aÅ›ciwoÅ›ci wszystkich platform, puÅ‚apek, przedmiotÃ³w, punktu startowego i koÅ„cowego. Pozwala to na niezwykle Å‚atwe tworzenie, modyfikowanie i dodawanie nowych poziomÃ³w bez dotykania gÅ‚Ã³wnej logiki gry.
*   **Ranking (`ranking.json`)**: Najlepsze wyniki sÄ… przechowywane w pliku JSON, co pozwala na ich trwaÅ‚e zapisywanie miÄ™dzy sesjami gry.

### 4. GÅ‚Ã³wna PÄ™tla Gry (`main()`)
Funkcja `main()` jest centrum operacyjnym. W pÄ™tli `while running:` wykonuje trzy gÅ‚Ã³wne zadania w kaÅ¼dej klatce:
1.  **ObsÅ‚uga ZdarzeÅ„:** Przetwarza wszystkie wejÅ›cia od uÅ¼ytkownika (klawiatura, zamkniÄ™cie okna).
2.  **Aktualizacja Logiki:** Na podstawie aktualnego `GameState` wywoÅ‚uje odpowiednie metody `.update()` dla gracza, poziomu i innych aktywnych obiektÃ³w. Tutaj odbywa siÄ™ caÅ‚a fizyka, sprawdzanie kolizji i zmiana stanÃ³w obiektÃ³w.
3.  **Renderowanie:** CzyÅ›ci ekran i wywoÅ‚uje metody `.draw()` dla wszystkich widocznych elementÃ³w, od tÅ‚a, przez obiekty poziomu, po interfejs uÅ¼ytkownika (HUD).

## Dodatkowa Dokumentacja Projektu

### Analiza Fragmentu Kodu: Wczytywanie PoziomÃ³w (Data-Driven Design)

Wybranym fragmentem do analizy jest konstruktor klasy `Level` (`__init__`). Jest to doskonaÅ‚y przykÅ‚ad podejÅ›cia **Data-Driven Design** zastosowanego w projekcie.

```python
# W klasie Level
def __init__(self, level_data, level_index):
    # ... inicjalizacja pustych grup i list ...
    self.background = LevelBackground(level_index, SCREEN_WIDTH, SCREEN_HEIGHT)

    # Wczytujemy platformy, przeszkody, przedmioty i strefÄ™ wyjÅ›cia
    for platform_data in level_data.get('platforms', []):
        self.platforms.add(Platform(**platform_data))
    # ... (podobne pÄ™tle dla 'temporal_platforms', 'hazards', 'collectibles', 'keys') ...

    # Wczytujemy strefÄ™ wyjÅ›cia
    self.start_pos = (level_data['start']['x'], level_data['start']['y'])
    end_data = level_data.get('end', {})
    self.exit_zone = ExitZone(end_data.get('x', 900), end_data.get('y', 100))
    self.exit_zone.locked = bool(self.keys)
```

Analiza:
Analiza: Ten fragment pokazuje, jak kod gry jest oddzielony od danych definiujÄ…cych poziom. Konstruktor nie tworzy "na sztywno" Å¼adnych obiektÃ³w. Zamiast tego iteruje po danych wczytanych z pliku .json i dynamicznie tworzy instancje odpowiednich klas, rozpakowujÄ…c ich wÅ‚aÅ›ciwoÅ›ci (**platform_data) jako argumenty. Takie podejÅ›cie jest niezwykle elastyczne i pozwala na tworzenie nowych poziomÃ³w przez edycjÄ™ plikÃ³w tekstowych, bez zmiany kodu gry.

### Proceduralne Generowanie TÅ‚a
Kolejnym interesujÄ…cym fragmentem jest konstruktor klasy LevelBackground, ktÃ³ry odpowiada za tworzenie unikalnego, dynamicznego tÅ‚a dla kaÅ¼dego poziomu.

```python
# W klasie LevelBackground
def __init__(self, level_index, width, height):
    random.seed(level_index) # UÅ¼ycie indeksu poziomu jako ziarna losowoÅ›ci
    
    # Generowanie koloru nieba
    base_blue = random.randint(10, 40)
    self.sky_color = (random.randint(0, 15), random.randint(0, 15), base_blue)

    # Generowanie gwiazd
    self.stars = []
    for _ in range(random.randint(100, 250)):
        self.stars.append({
            'pos': (random.randint(0, width), random.randint(0, height)),
            'size': random.uniform(0.5, 2)
        })

    # Generowanie chmur z rÃ³Å¼nymi prÄ™dkoÅ›ciami dla efektu paralaksy
    self.clouds = []
    for _ in range(random.randint(5, 15)):
        self.clouds.append({
            'rect': pygame.Rect(random.randint(-100, width + 100), random.randint(20, height // 2), 
                                random.randint(100, 300), random.randint(20, 50)),
            'speed': random.uniform(0.1, 0.5)
        })
    random.seed() # Reset ziarna losowoÅ›ci
```

Analiza: Ten kod jest doskonaÅ‚ym przykÅ‚adem generowania proceduralnego, ktÃ³re nadaje grze wizualnej gÅ‚Ä™bi i rÃ³Å¼norodnoÅ›ci bez potrzeby tworzenia i wczytywania dziesiÄ…tek osobnych plikÃ³w graficznych.


### Deterministyczna LosowoÅ›Ä‡: 
Kluczowym elementem jest linia **random.seed(level_index)**. Ustawienie "ziarna" generatora liczb losowych na podstawie numeru poziomu sprawia, Å¼e dla danego poziomu tÅ‚o bÄ™dzie zawsze wyglÄ…daÄ‡ tak samo, ale tÅ‚a rÃ³Å¼nych poziomÃ³w bÄ™dÄ… siÄ™ od siebie rÃ³Å¼niÄ‡.

### Dynamiczny Kolor Nieba: 
Kolor nieba nie jest staÅ‚y. Jest losowany, co pozwala uzyskaÄ‡ rÃ³Å¼ne odcienie, od gÅ‚Ä™bokiego granatu po jaÅ›niejszy bÅ‚Ä™kit, nadajÄ…c kaÅ¼demu poziomowi unikalny nastrÃ³j.
Generowanie Gwiazd i Chmur: Pozycje, rozmiary i liczba gwiazd oraz chmur sÄ… losowane w okreÅ›lonych przedziaÅ‚ach. Co waÅ¼ne, chmury otrzymujÄ… losowÄ… prÄ™dkoÅ›Ä‡ (speed), co jest pÃ³Åºniej wykorzystywane do stworzenia efektu paralaksy â€“ chmury na rÃ³Å¼nych planach poruszajÄ… siÄ™ z rÃ³Å¼nÄ… prÄ™dkoÅ›ciÄ… wzglÄ™dem gracza, co tworzy iluzjÄ™ gÅ‚Ä™bi.

### EfektywnoÅ›Ä‡: 
Takie podejÅ›cie jest niezwykle wydajne. Zamiast wczytywaÄ‡ duÅ¼e pliki graficzne, gra generuje caÅ‚Ä… sceneriÄ™ w uÅ‚amku sekundy, uÅ¼ywajÄ…c jedynie kilku prostych operacji matematycznych.
Wyzwania i Napotkane Problemy
Podczas tworzenia projektu napotkano kilka kluczowych wyzwaÅ„:


### Implementacja Echa: 
**NajwiÄ™kszym wyzwaniem** byÅ‚o efektywne przechowywanie i odtwarzanie historii ruchÃ³w gracza. Zastosowanie struktury **collections.deque** z ograniczonÄ… dÅ‚ugoÅ›ciÄ… **(maxlen=ECHO_DELAY_FRAMES)** okazaÅ‚o siÄ™ idealnym rozwiÄ…zaniem, ktÃ³re jest wydajne i automatycznie zarzÄ…dza "oknem czasowym" 10 sekund.
Fizyka i Kolizje z Platformami Czasowymi: ObsÅ‚uga kolizji z platformami, ktÃ³re mogÄ… byÄ‡ materialne lub nie, wymagaÅ‚a dynamicznego podejÅ›cia. Problem rozwiÄ…zano przez stworzenie metody **level.get_solid_platforms()**, ktÃ³ra w kaÅ¼dej klatce zwraca grupÄ™ tylko tych platform, z ktÃ³rymi moÅ¼na wejÅ›Ä‡ w interakcjÄ™. 
Gracz sprawdza kolizje tylko z tÄ… dynamicznie generowanÄ… grupÄ….

### ZarzÄ…dzanie Stanami Gry: 
Gra posiada wiele ekranÃ³w **(menu, gra, pauza, ranking)**. PoczÄ…tkowo prowadziÅ‚o to do skomplikowanych warunkÃ³w **if/else**. 
Wprowadzenie **Enum** dla **GameState** i oparcie gÅ‚Ã³wnej pÄ™tli na tej maszynie stanÃ³w znaczÄ…co uproÅ›ciÅ‚o kod i uczyniÅ‚o go bardziej czytelnym


### Kluczowe Elementy Fragmentu
1. **Inicjalizacja TÅ‚a:** `self.background = LevelBackground(level_index, SCREEN_WIDTH, SCREEN_HEIGHT)` tworzy unikalne tÅ‚o dla poziomu, co jest kluczowe dla estetyki gry.
2. **Wczytywanie ElementÃ³w:** PÄ™tle `for` iterujÄ… przez dane z pliku JSON, tworzÄ…c instancje odpowiednich klas (`Platform`, `Hazard`, `Collectible` itp.). DziÄ™ki temu kod jest czysty i Å‚atwy do rozszerzenia.
3. **ZarzÄ…dzanie StrefÄ… WyjÅ›cia:** `self.exit_zone.locked = bool(self.keys)` ustawia stan strefy wyjÅ›cia w zaleÅ¼noÅ›ci od tego, czy gracz zebraÅ‚ wszystkie klucze, co jest kluczowym elementem rozgrywki.
4. **ElastycznoÅ›Ä‡ i RozszerzalnoÅ›Ä‡:** DziÄ™ki temu podejÅ›ciu, dodanie nowego poziomu polega jedynie na stworzeniu nowego pliku JSON, co znacznie uÅ‚atwia rozwÃ³j gry i pozwala na Å‚atwe testowanie nowych pomysÅ‚Ã³w.
5. **CzytelnoÅ›Ä‡ i Utrzymanie:** Kod jest czytelny i Å‚atwy do zrozumienia, co jest kluczowe w wiÄ™kszych projektach. DziÄ™ki zastosowaniu sÅ‚ownikÃ³w i argumentÃ³w sÅ‚Ã³w kluczowych (`**platform_data`), moÅ¼na Å‚atwo dodawaÄ‡ nowe wÅ‚aÅ›ciwoÅ›ci do platform bez koniecznoÅ›ci zmiany logiki wczytywania.
6. **Separacja Logiki i Danych:** Logika gry jest oddzielona od danych poziomu, co pozwala na Å‚atwe modyfikowanie poziomÃ³w bez ingerencji w kod gry. To podejÅ›cie jest kluczowe dla skalowalnoÅ›ci projektu.
7. **WydajnoÅ›Ä‡:** Wczytywanie danych z pliku JSON jest efektywne i pozwala na szybkie Å‚adowanie poziomÃ³w, co jest istotne dla pÅ‚ynnoÅ›ci rozgrywki.

## Wnioski
`Quantum Echo` to projekt, ktÃ³ry Å‚Ä…czy w sobie innowacyjne mechaniki rozgrywki z solidnÄ… architekturÄ… kodu. DziÄ™ki zastosowaniu podejÅ›cia Data-Driven Design, gra jest Å‚atwa do rozszerzenia i modyfikacji, co pozwala na szybkie wprowadzanie nowych poziomÃ³w i funkcji. Mechaniki takie jak Echo Czasowe i Kwantowa Zamiana wprowadzajÄ… unikalne wyzwania, ktÃ³re zmuszajÄ… graczy do myÅ›lenia w nowy sposÃ³b, czyniÄ…c kaÅ¼dÄ… sesjÄ™ gry Å›wieÅ¼Ä… i ekscytujÄ…cÄ….
